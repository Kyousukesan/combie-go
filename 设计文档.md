# Go 组件 —— combine

## 1. 简介

`combine` 是一个用于 **聚合计算** 的 Go 公共组件。  
它支持通过在字段注释中指定聚合函数和输入字段，实现灵活的自定义聚合。  
支持函数结果命名，并且通过 **Option 模式** 进行初始化，默认不开启并行聚合。

---

## 2. 核心特性

- 通过 struct tag `combine:"函数名,输出字段"` 指定聚合规则
- 支持自定义函数扩展
- 支持链式上下文参数配置
- 默认不开启并行聚合，可选开启并行
- 保持输入列表数量不变，只对聚合字段生效

---

## 3. 使用方式

### 3.1 定义结构体

```go
type Item struct {
    Name   string  `json:"name"`
    Amount float64 `json:"amount" combine:"sum,total_amount"`
    Count  int     `json:"count"  combine:"count,total_count"`
}
```

### 3.2 初始化 Combine

使用 Option 模式：

```go
combine := NewCombine(
    WithConcurrent(), // 显式开启并行聚合
    WithCtx().
        Set("factor", 1.5).
        Set("env", "prod").
        Build(),
)
```

### 3.3 执行聚合

```go
items := []Item{
    {Name: "a", Amount: 10, Count: 1},
    {Name: "b", Amount: 20, Count: 2},
}

result, err := combine.Do(items)
if err != nil {
    log.Fatal(err)
}

fmt.Printf("%+v\n", result)
```

---

## 4. Option 定义

```go
type Option func(*Combine)

// 并行聚合开关
func WithConcurrent() Option {
    return func(c *Combine) {
        c.concurrent = true
    }
}
```

---

## 5. 链式上下文参数

通过 `WithCtx` 实现链式设置：

```go
type CtxOption struct {
    ctx map[string]any
}

func WithCtx() *CtxOption {
    return &CtxOption{ctx: make(map[string]any)}
}

func (co *CtxOption) Set(key string, value any) *CtxOption {
    co.ctx[key] = value
    return co
}

// 转换为 Option
func (co *CtxOption) Build() Option {
    return func(c *Combine) {
        for k, v := range co.ctx {
            c.combineCtx[k] = v
        }
    }
}
```

---

## 6. Combine 结构体与构造函数

```go
type Combine struct {
    concurrent bool
    combineCtx map[string]any
    // 其他字段...
}

func NewCombine(opts ...Option) *Combine {
    c := &Combine{
        concurrent: false,          // 默认不并行
        combineCtx: make(map[string]any),
    }
    for _, opt := range opts {
        opt(c)
    }
    return c
}
```

---

## 7. 自定义聚合函数

```go
// 聚合函数签名
type AggFunc func(values []any, ctx map[string]any) (any, error)

// 注册自定义函数
func RegisterFunc(name string, fn AggFunc) {
    aggFuncRegistry[name] = fn
}

// 示例：加权求和
RegisterFunc("weighted_sum", func(values []any, ctx map[string]any) (any, error) {
    factor, ok := ctx["factor"].(float64)
    if !ok {
        factor = 1.0
    }
    sum := 0.0
    for _, v := range values {
        if num, ok := v.(float64); ok {
            sum += num * factor
        }
    }
    return sum, nil
})
```

---

## 8. 示例：使用自定义函数

```go
type Order struct {
    Price float64 `combine:"weighted_sum,total_price"`
}

orders := []Order{
    {Price: 100},
    {Price: 200},
}

combine := NewCombine(
    WithCtx().
        Set("factor", 1.2).
        Build(),
)

result, _ := combine.Do(orders)
fmt.Println(result)
```

---

## 9. 附

- 本组件设计灵感来源于 Go 社区常见的 **Option 模式**
- 可扩展性强，便于在大规模 B 端系统中应用
